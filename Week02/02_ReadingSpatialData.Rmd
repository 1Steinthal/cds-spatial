---
title: "Week 02 - Introduction to Reading and Plotting Spatial Data"
author: "Adela Sobotkova"
date: "04/01/2021 updated `r Sys.Date()`"
output:
  rmdformats::readthedown:
    highlight: kate
---

```{r setup, include=FALSE}
library(knitr)
library(rmdformats)

## Global options
options(max.print="75")
opts_chunk$set(echo=FALSE,
	             cache=TRUE,
               prompt=FALSE,
               tidy=TRUE,
               comment=NA,
               message=FALSE,
               warning=FALSE)
opts_knit$set(width=75)
```

# Introduction into GIS in R
There are a few key spatial packages available for Spatial Analysis in R, which you need to install as you progress through these exercises. The most basic are 

* `sf` for working with vector data
* `raster` for working with raster data
* `rgdal` for an R-friendly GDAL interface

The installation of the geospatial libraries GDAL, GEOS and PROJ.4 varies significantly based on operating system (and can be entailed). All of these are dependencies for `sf`, the R package that we will be using for spatial data operations throughout this course. Please follow the Option A: Local installation instructions for your operating system on [this page](https://datacarpentry.org/geospatial-workshop/setup.html) under the heading GDAL, GEOS, and PROJ.4 and continue through the R Packages. Click on the linked pages to make your life easier.

# Task 1: Reading vector data
The `sf` package, created by Edzer Pebesma and colleagues, has dramatically simplified reading vector spatial data into R.

In this exercise you will read in three shapefiles (one point file and two polygon files) using `st_read()`. If you've read in the files correctly, you will see a standard R data frame except it will show some header metadata about the file and you'll see a special `geometry` column which we will discuss later.

## Instructions

* Load the `sf` package.
* All your datasets reside in the 'data' folder.
* Import the `mounds` shapefile ("mounds.shp").
* Import the `municipalities` shapefile ("municipalities.shp").
* Import the `survey` shapefile ("survey.shp").
* Use the `head()` function and identify the first few mounds.

```{r load, eval=FALSE, echo=TRUE}
# Load the sf package
___(___)

# Read in the mounds shapefile
mounds <- ___("data/mounds.shp")

# Read in the municipality shapefile
municipalities <- ___(___)

# Read in the survey shapefile
survey <- ___(___)

# View the first few mounds
___(___)
```

## Questions: 

1. How many features do `mounds` contain and what kind of geometry are they?
2. How many features are there inside `municipalities` and what is their geometry?
3. What is the CRS value in these objects?


### Solution
```{r load data, echo = FALSE}
# Load the sf package
library(sf)

# Read in the mounds shapefile
mounds <- st_read("data/mounds.shp")

# Read in the municipality shapefile
municipalities <- st_read("data/municipalities.shp")

# Read in the survey shapefile
survey <- st_read("data/survey.shp")

# View the first few mounds
head(mounds)

# Answers
# yyy mounds; XXX municipalities;CRS=32635
```

Well done, now you should see how easy it can be to read in shapefiles and you got your first taste of what an sf object looks like.

<br>


# Task 2: sf objects are data frames
Spatial objects in `sf` are just data frames with some special properties. This means that packages like `dplyr` can be used to manipulate `sf` objects. In this exercise, you will use the `dplyr` functions `select()` to select or drop variables, `filter()` to filter the data and `mutate()` to add or alter columns.


## Instructions

* Load the `dplyr` and `sf` packages.
* Read in the `mounds` shapefile with `st_read()` (the file is "mounds.shp").
* Use the `filter()` function from `dplyr` on the `mounds` object to create a new data frame limited to mounds over 5m.
* Use the `nrow()` function on your new object to determine how many mounds over 5m are in the dataset.
* Use the `select()` function from dplyr to limit the variables in your over5m dataset to just `TRAP_Code` and `Height` and create a new data frame.
* Use the `head()` function to check which variables exist in your new data frame. Does the data frame only have the `TRAP_Code` and `Height` columns (the answer is no, we'll discuss later)?

```{r wrangle-mounds, eval=FALSE, echo=TRUE}
# Load the sf package
___

# ... and the dplyr package
___

# Read in the mounds shapefile
___

# Use filter() to limit to over5m mounds
___

# Count the number of rows
___(over5m)

# Limit to TRAP_Code and Height variables
over5_lim <- over5m %>% ___(TRAP_Code, Height) 

# Use head() to look at the first few records
___(over5_lim)
```


### Solution
```{r wrangle-mounds-sol, echo=FALSE}
# Load the sf package
library(sf)

# ... and the dplyr (or tidyverse) package
library(dplyr)

# Read in the mounds shapefile
mounds <- st_read("data/mounds.shp")

# Use filter() to limit to over5m mounds
over5m <- mounds %>% 
  filter(Height > 5)

# Count the number of rows
nrow(over5m)

# Limit to TRAP_Code and Height variables
over5_lim <- over5m %>% select(TRAP_ID, Height) 

# Use head() to look at the first few records
head(over5_lim)
```
Great! You can see why the `sf` package is so nice â€“ your spatial objects are data frames that you can smoothly manipulate with `dplyr`. The number of mounds over 5m is 38. Try and see how many are below 1.5m; you should arrive at 504.
You may have noticed that when you used `select` the default is to keep the geometry column even if you didn't explicitly list it as a column in select.


# Task 3: Geometry is stored in list-columns
A major innovation in `sf` is that spatial objects are data frames. This is possible thanks, in part, to the list-column.

A list-column behaves, to a certain extent, like any other R column. The main difference is that instead of a standard value such as a single number, character or boolean value, each observation value in that column is a piece of an R list and this list can be as complex as needed. The list column allows you to store far more information in a single variable and `sf` takes advantage of this by storing all geographic information for each feature in the list.

In this exercise, you will convert the data frame to what's called a `tibble` with `tibble::as_tibble()` (Note that `dplyr::tbl_df()` is now deprecated).

## Instructions

* Load tidyverse in your workspace.
* Create a simple data frame `df` that includes a single column `a` using `data.frame()`.
* Add a list-column `b` to your data frame with the `list()` function.
* Use `head()` to look at `df`.
* Use `as_tibble()` to convert the data frame to a tibble and print it to the console. This is just for cleaner printing.
* Pull out the third observation from columns `a` and `b` using `base` R (you'll need square brackets like `[3]`).

```{r geometry, eval = FALSE, echo = TRUE}
# Create a standard, non-spatial data frame with one column
df <- ___(a = 1:3)

# Add a list column to your data frame
df$b <- ___(1:4, 1:5, 1:10)

# Look at your data frame with head
___(df)

# Convert your data frame to a tibble and print on console
___(df)

# Pull out the third observation from both columns individually
df$___[___]
df$___[___]
```

### Solution
```{r lists, echo=FALSE}
# Create a standard, non-spatial data frame with one column
df <- data.frame(a = 1:3)

# Add a list column to your data frame
df$b <- list(1:4, 1:5, 1:10)

# Look at your data frame with head
head(df)

# Convert your data frame to a tibble and print on console
as_tibble(df)

# Pull out the third observation from both columns individually
df$a[3]
df$b[3]
```
You now have a better sense of what a list column is. You can see how it can be used to store far more information in a single variable than other types of columns. These list-columns are how `sf` stores detailed geographic information on each feature in a single record. Converting the data frame to a tibble is not necessary but a tibble can provide a better print out of the object.

# Task 4: Extract geometric information from your vector layers
There are several functions in `sf` that allow you to access geometric information like area from your vector features. For example, the functions `st_area()` and `st_length()` return the area and length of your features, respectively.

Note that the result of functions like `st_area()` and `st_length()` will not be a traditional vector. Instead the result has a class of `units` which means the vector result is accompanied by metadata describing the object's units. As a result, code like this won't quite work:

```{r example1, eval=FALSE, echo=TRUE}
# This will not work
result <- st_area(survey)
result > 30000
```

Instead you need to either remove the units with `unclass()`:

```{r example2, eval=FALSE, echo=TRUE}
# This will work
val <- 30000
which(unclass(result) > 30000)
```

or you need to convert `val`'s class to `units`, for example:

```{r example3, eval=FALSE, echo=TRUE}
# This will work
units(val) <- units(result)
which(result > val)
```


## Instructions

* Check that your `sf` library is still active and then read in the `survey` shapefile (the file is "survey.shp") 
* Compute the area of the survey units.
* Create a histogram of the areas using `hist()` to quickly visualize the data spread.
* Filter the survey object with `filter()` and limit to survey with `unclass(areas)` > 30000 (areas greater than 30,000 square meters).
* Plot the geometry of the result with `plot()` and `st_geometry()`.

```{r survey, eval=FALSE, echo=TRUE}
# Read in the survey shapefile
survey <- ___(___)

# Compute the areas of the survey
areas <- ___(survey)

# Create a quick histogram of the areas using hist
___(___, xlim = c(0, 200000), breaks = 1000)

# Filter to survey greater than 30000 (square meters)
big_survey <- ___ %>% ___(___(___) > 30000)

# Plot just the geometry of big_survey
___(___(big_survey))
```



### Solution
```{r survey-sol, echo=FALSE}
# Read in the survey shapefile
survey <- st_read("data/survey.shp")

# Compute the areas of the survey
areas <- st_area(survey)

# Create a quick histogram of the areas using hist
hist(areas, xlim = c(0, 200000), breaks = 1000)

# Filter to survey greater than 30000 (square meters)
big_survey <- survey %>% filter(unclass(areas) > 30000)

# Plot just the geometry of big_survey
plot(st_geometry(big_survey))
```

Excellent! Computing geographic information for your vector layers can be done with functions like `st_area()` and `st_length()`. As you saw in this exercise, these functions produce a result that can be used in additional calculations but you need to be careful because the result is a `units` object that requires a little additional processing like using `unclass()`.


# Task 5: Plot vector spatial objects
The function for making a quick map/plot is a function you are already familiar with, `plot()`. You can, for example, type `plot(my_data)` to see your spatial object. The default, though, may not be what you want. The `plot()` function, when applied to `sf` objects, will create a set of maps, one for each attribute in your data. Instead, if you want to create a map of a single attribute you can extract that attribute using, as an example, `plot(my_data["my_variable"])`.

Frequently you just want to plot the raw geometry with no attribute color-coding (e.g., adding county boundaries to a map of points). For this, you can use the `st_geometry()` function to extract the geometry and plot the result. You can either create a new object or you can nest `st_geometry()` within the `plot()` function.

## Instructions

* Load the package `sf` and the `survey` object if you have removed them from your workspace.
* Use `plot()` to plot the `survey` data using all defaults.
* Plot just the `Area_ha` attribute of survey.
* Create a new object that is just the geometry of the survey object with `st_geometry()`.
* Plot the geometry of the survey (the object you just created).

```{r plotting-sf, eval=FALSE}
# Plot the survey object using all defaults
___(survey)

# Plot just the Area_ha attribute of the survey data
___(survey[___])

# Create a new object of just the survey geometry
survey_geo <- ___(survey)

# Plot the geometry of the survey data
___(survey_geo)
```

### Solution
```{r plotting-sf-sol, echo=FALSE}
# Plot the survey object using all defaults
plot(survey)

# Plot just the Area_ha attribute of the survey data
plot(survey["Area_ha"])

# Create a new object of just the survey geometry
survey_geo <- st_geometry(survey)

# Plot the geometry of the survey data
plot(survey_geo)
```

Well done! Yes, these plots are not pretty but you can't beat `plot()` for a quick look using few keystrokes. And remember you can use `plot(st_geometry(geo_object))` to plot just the geometry of your object.


# Task 6: Reading in raster data
The term "raster" refers to gridded data that can include satellite imagery, aerial photographs (like orthophotos) and other types. In R, raster data can be handled using the `raster` package created by Robert J. Hijmans.

When working with raster data, one of the most important things to keep in mind is that the raw data can be what is known as "single-band" or "multi-band" and these are handled a little differently in R. Single-band rasters are the simplest, these have a single layer of raster values -- a classic example would be an elevation raster where each cell value represents the elevation at that location.

Multi-band rasters will have more than one layer. An example is a color aerial photo in which there would be one band each representing red, green or blue light (RGB).

## Instructions

* Load the `raster` package.
* Read in the mound elevation raster with the `raster()` function (this is a single-band raster called "AsterRcl.tif").
* Read in the IKONOS satellite image with `brick()` (this is  multi-band raster called "Kaz.tif").
* Use the `class()` function to determine the class of each raster object you read in.
* Use the `nlayers()` function to determine how many bands/layers are in each object.

```{r loadraster, eval=FALSE, echo=TRUE}
# Load the raster package
___(___)

# Read in the mound elevation single-band raster
elevation <- ___(___)

# Read in the IKONOS image multi-band rasters
kaz <- brick(_____)

# Get the class for the new objects
class(___)
class(___)

# Identify how many layers each object has
nlayers(___)
nlayers(___)
```

Questions:

1. What are the dimensions (number of columns and rows) of the `elevation` raster?
2. What is the resolution of `kaz` Ikonos image? How many layers does it contain and what do they represent?

Now you've learned how to read in single and multi-band rasters. You should have noticed, based on the `nlayers()` function, that the `elevation` object has a single layer and the `kaz` object has four.

### Solution
```{r loadrasters, echo=FALSE}
# Load the raster package
library(raster)

# Read in the mound elevation single-band raster
elevation <- raster("data/AsterRcl.tif")

# Read in the Ikonos  image multi-band raster
kaz <- brick("data/Kaz.tif")


# Get the class for the new objects
class(elevation)
class(kaz)

# Identify how many layers each object has
nlayers(elevation)
nlayers(kaz)

# Identify the resolution of each raster
res(elevation)
res(kaz)

# Answers
# 1. 1;4
# 2. 30,30; 10,10
```


# Task 7: Learn about your raster objects
Instead of storing raster objects in data frames, the `raster` package stores spatial data in specially designed R classes that contain slots where the data and metadata are stored. The data and metadata can be accessed using a suite of functions. For example, the spatial extent (the bounding box) of the object can be accessed with `extent()`, the coordinate reference system can be accessed with `crs()` and the number of grid cells can be determined with `ncell()`.

## Instructions

* You should have `raster` package loaded, and have the  elevation layer (based on  single-band raster called "AsterRcl.tif") and IKONOS satellite image layer for Kazanlak Valley (multi-band raster called "Kaz.tif") in memory.
* Use the `extent()` function to get the extent of the elevation layer.
* Use the `crs()` function to get the coordinate reference system of `kaz`.
* Use the `ncell()` function to determine how many grid cells are in the elevation layer and the Kaz layer.

```{r load raster, eval=FALSE, echo=TRUE}
# Load the raster package
___(___)

# Read in the rasters if you lost them
elevation <- ___("data/AsterRcl.tif")
kaz <- ___("data/Kaz.tif")

# Get the extent of the elevation object
___(___)

# Get the CRS of the kaz object
___(___)

# Determine the number of grid cells in both raster objects
___(kaz)
___(elevation)
```

### Solution
```{r load raster sol, echo=FALSE}
# Load the raster package
library(raster)

# Read in the rasters
elevation <- raster("data/AsterRcl.tif")
kaz <- brick("data/Kaz.tif")

# Get the extent of the elevation object
extent(elevation)

# Get the CRS of the kaz object
crs(kaz)

# Determine the number of grid cells in both raster objects
ncell(kaz)
ncell(elevation)
```
Great work! Although rasters are not stored as data frames, the metadata can easily be extracted using functions like `extent()`, `crs()` and `ncell()`.


# Task 8: Plot your raster object
Similar to what you saw in the exercises related to vector objects it's often useful to quickly look at a map of your raster objects with the `plot()` function.

The raster package has added useful methods for plotting both single and multi-band rasters. For single-band rasters or for a map of each layer in a multi-band raster you can simply use `plot()`. If you have a multi-band raster with layers for red, green and blue light you can use the `plotRGB()` function to plot the raster layers together as a single image.

## Instructions

* Plot the `elevation` raster with the `plot()` function, it is a single-band raster called `elevation`.
* Plot the `kaz` object with the `plot()` function, it is a multi-band raster called `kaz`.
* Plot the `kaz` raster with `plotRGB()` to see all layers plotted together as a single image. Check out the optional `stretch` argument in this function, and set it to `linear` to brighten the image up a little
```{r plot raster, eval=FALSE, echo=TRUE }
# Plot the elevation raster (single raster)
___

# Plot the kaz raster (as a single image for each layer)
___

# Plot the kaz raster as an image
____
```

### Solution
```{r plot raster sol, echo=FALSE}
# Plot the elevation raster (single raster)
plot(elevation)

# Plot the kaz raster (as a single image for each layer)
plot(kaz)

# Plot the kaz raster as an image
plotRGB(kaz, stretch = "lin")
```

Nice work! As you can see, the `plot()` function can be used to plot single layers while the `plotRGB()` function can be used to combine layers into a single image.