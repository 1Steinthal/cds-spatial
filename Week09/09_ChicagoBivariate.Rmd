---
title: "Chicago Crime: Bivariate Point patterns"
author: "Adela Sobotkova"
date: "March-2022 updated `r Sys.Date()`"
output:
  rmdformats::readthedown:
    highlight: kate
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r libraries-data-sol, include=FALSE}
library(raster)
library(sf)
library(tidyverse)
```


# Task 1: Create ppp object for Chicago crime
## Select crime data

```{r}

# Load crime data the from Chicago data portal or from root data folder
# https://data.cityofchicago.org/Public-Safety/Crimes-2017/d62x-nvdr
crimes <- read_csv("../Week01/data/ChicagoCrimes2017.csv")
glimpse(crimes)


# Check out the varied crime categories
unique(crimes$`Primary Type`)

crimes %>%
  group_by(`Primary Type`) %>%
  tally()


# Select different kinds of crime
crimeCH <- crimes %>%
    filter(`Primary Type` %in% c("HOMICIDE","SEX OFFENSE", "NARCOTICS", "MOTOR VEHICLE THEFT", "ARSON", "LIQUOR LAW VIOLATION")) %>%
    filter(!is.na(Latitude))

crimeCH %>%
  group_by(`Primary Type`) %>%
  tally()

library(sf)
crimeCH <-  crimeCH %>%
  st_as_sf(coords = c("Longitude", "Latitude"), crs = 4326) %>%
  st_transform(crs = 26916) # NAD83 UTM Zone 16N (EPSG 26916)

```

## Find Chicago city boundary for a suitable window
You can find a bunch of spatial data on Chicago at this [portal](https://data.cityofchicago.org/Facilities-Geographic-Boundaries/Boundaries-City/ewy2-6yfk)

```{r}
city <- st_read("../data/ChicagoCity/geo_export_7e521de8-1084-4c3c-9c4f-119af49f9ef9.shp")
city <- city %>% st_transform(crs =26916)

plot(city$geometry); plot(crimeCH %>% filter(`Primary Type`== "HOMICIDE") %>% st_geometry(), add =T, col = "red")

```

## Create a ppp object out of the data
```{r}
library(spatstat)
# Coerce city border simple feature to an object of class “owin” (observation window)
cityOwin <- as.owin(city)
class(cityOwin)

#Extract coordinates from simple feature:
pts <- st_coordinates(crimeCH)
head(pts)

#Now we can create a ‘ppp’ (point pattern) object
p <- ppp(pts[,1], pts[,2], window=cityOwin)


# Create a marked point pattern object (ppp) for all crimes. It is important to coerce the marks to a factor variable.
crimeCH$fcat <- as.factor(crimeCH$`Primary Type`)
chicago_crime <- ppp(pts[,1], pts[,2], window = cityOwin, marks=crimeCH$fcat)
```
### Look at the result

```{r plot}
# We can split the chicago_crime object by category (crime)
spp <- split(chicago_crime)
plot(spp[1:4], main='')

#The crime density by category:

plot(density(spp[1:4]), main='')
```

### Explore the data

* Use the `summary()` function to explore the basic properties of `chicago_crime`.
* Get a table of counts of violent/non-violent crimes.
  - Pass the point pattern, `chicago_crime`, to `marks()`.
  - Wrap that in a call to `table()` to get the counts.
* The map looks better when the point markers are black and red, using different sizes for violent and non-violent crimes, and with the solid point marker. This marker has code number 19.
```{r}
summary(chicago_crime)
table(marks(chicago_crime))

chicago_map <- function(cols = c("green","red", "blue", "yellow"), cex = c(1, 1,1,1), pch = c(1, 1, 1, 1)) {
  plot(city$geometry) # loaded above
  plot(chicago_crime, cols = cols, pch = pch, cex = cex, add = TRUE, show.window = TRUE)
}

# Draw the map with colors, sizes and plot character
chicago_map(
  cols = c("black", "red", "yellow", "blue"), 
  cex = c(0.5, 1), 
  pch = 19
)
```


# Task 2: Look at the patterns in different kinds of crimes 

```{r}
#K-plots for liquor violations and Arson

spatstat.options(checksegments = FALSE)
ktheft <- Kest(spp$`LIQUOR LAW VIOLATION`)
plot(ktheft)
#ketheft <- envelope(spp$`LIQUOR LAW VIOLATION`, Kest)

karson <- Kest(spp$ARSON)
plot(karson)
#karson <- envelope(spp$ARSON, Kest)

```

# Task 3: Look at criminal activity correlation

Does drinking lead to arson or another crime? How would test for spatial dependency of these two types of offensive behavior?

```{r}
kc <- Kcross(chicago_crime, i = "LIQUOR LAW VIOLATION", j = "ARSON")
plot(kc)
#ekc <- envelope(chicago_crime, Kcross, nsim = 50, i = "Drunk in Public", j = "Arson")

```

# Task 4: Save data
```{r}
saveRDS(crimeCH, "data/crimeCH.rds")
saveRDS(chicago_crime, "data/crimeCH-spatstat.rds") # save marker planar point
chicago_crime <- readRDS("../data/crimeCH-spatstat.rds")
```


# Task 5: Create a new ppp object for Chicago crime

Construct a new `ppp` object out of simple feature called `chicago_crime_violent` which you created by selecting homicide, assault, theft and robbery out of the Chicago crimes dataset. Make this object into a **marked** point process, marking homicide and assault as a "Violent Crime", and theft and robbery as "Non-violent crime". The marks for each point can be retrieved using the `marks()` function. The window is a 4km circle centered on the town center.

* filter the crimes dataset for homicide, assault, theft, robbery
* filter away any points without coordinates
*
```{r}

crimes$`Primary Type`
# select data and create a new column
crime_v <- crimes %>%
    filter(`Primary Type` %in% c("HOMICIDE","ASSAULT", "THEFT", "ROBBERY")) %>%
    filter(!is.na(Latitude)) %>%
  mutate(crimetype = case_when(
    `Primary Type` == "HOMICIDE" ~ "VIOLENT",
    `Primary Type` == "ASSAULT" ~ "VIOLENT",
    `Primary Type` == "THEFT"  ~ "NON-VIOLENT",
    `Primary Type` == "ROBBERY" ~ "NON-VIOLENT"))

# make into simple features
library(sf)
crime_v <-  crime_v  %>% 
  st_as_sf(coords = c("Longitude", "Latitude"), crs = 4326) %>%
  st_transform(crs = 26916) # NAD83 UTM Zone 16N (EPSG 26916)

# view the simple features
plot(st_geometry(crime_v["crimetype"== "NON-VIOLENT"]))
plot(st_geometry(crime_v["crimetype"== "VIOLENT"]))


```
```{r}
# Create rasterized views
library(raster)
?rasterize()
r <- raster(ncol= 50, nrow = 200)
extent(r) <- extent(city)
nv <- rasterize(st_coordinates(crime_v["crimetype"== "NON-VIOLENT"]), r)
v <- rasterize(st_coordinates(crime_v["crimetype"== "VIOLENT"]), r)

plot(nv)
plot(v)
```

Make a ppp
```{r}
#Extract coordinates from simple feature:
pts <- st_coordinates(crime_v)
head(pts)

#Now we can create a ‘ppp’ (point pattern) object
p <- ppp(pts[,1], pts[,2], window=cityOwin)


# Create a marked point pattern object (ppp) for all crimes. It is important to coerce the marks to a factor variable.
crime_v$fcat <- as.factor(crime_v$`Primary Type`)
chicago_vcrime <- ppp(pts[,1], pts[,2], window = cityOwin, marks=crime_v$fcat)
plot(split(chicago_vcrime[1:1000]))

crime_violent<- ppp(pts[,1], 
                            pts[,2], 
                            window = cityOwin, 
                            marks=as.factor(crime_v$crimetype))
```


# Task 6: Violent crime proportion estimation

One method of computing a smooth intensity surface from a set of points is to use *kernel smoothing*. Imagine replacing each point with a dot of ink on absorbent paper. Each individual ink drop spreads out into a patch with a dark center, and multiple drops add together and make the paper even darker. With the right amount of ink in each drop, and with paper of the right absorbency, you can create a fair impression of the density of the original points. In kernel smoothing jargon, this means computing a **bandwidth** and using a particular **kernel** function.

To get a smooth map of violent crimes proportion, we can estimate the intensity surface for violent and non-violent crimes, and take the ratio. To do this with the `density()` function in `spatstat`, we have to split the points according to the two values of the marks and then compute the ratio of the violent crime surface to the total. The function has sensible defaults for the kernel function and bandwidth to guarantee something that looks at least plausible.

## Instructions

The `crime_violent` object and `spatstat` have been loaded.

* The `split()` function in `spatstat` will divide a marked point pattern by a categorical mark and return a list of point patterns. Split `crime_violent` and assign the result to `crime_splits`. You can subset the crime dataset to 1000 first points to actually see a pattern in the plot tat follows next.
* Plot `crime_splits` by calling `plot()`, with no other arguments.
* The `density()` function will work on a list of point patterns and return a list of densities. Calculate the densities of `crime_splits` and assign the result to crime_densities.
* Calculate the density of the fraction of violent crimes.
  - You can use `[[i]]` indexing to get the `i`-th density from a split list..
  - Basic arithmetic operators (such as `+`,` -`, `*` and `/`) can be used on densities.
  - Assign the result to `frac_violent_crime_density`.
* Plot `frac_violent_crime_density` by calling `plot()`, with no other arguments.
 
```{r crime-density-sample, eval = FALSE}
# crime_violent has been pre-defined
crime_violent

# Use the split function to show the two point patterns
crime_splits <- ___

# Plot the split crime
___

# Compute the densities of both sets of points
crime_densities <- ___

# Calc the violent density divided by the sum of both
frac_violent_crime_density <- crime_densities[[___]] / 
  (crime_densities[[___]] + crime_densities[[___]])

# Plot the density of the fraction of violent crime
plot(frac_violent_crime_density)
```
 

```{r crime-density-sample-sol, echo = FALSE}
# crime_violent has been pre-defined
crime_violent

# Use the split function to show the two point patterns
crime_splits <- split(crime_violent[1:1000])


# Plot the split crime
plot(crime_splits)

# Compute the densities of both sets of points
crime_densities <- density(crime_splits)

# Calc the violent density divided by the sum of both
frac_violent_crime_density <- crime_densities[["VIOLENT"]] / 
  (crime_densities[["NON-VIOLENT"]] + crime_densities[["VIOLENT"]])

# Plot the density of the fraction of violent crime
plot(frac_violent_crime_density)
```


Amazing crime density discovery! Notice how you can do arithmetic on the pixel image objects.
Next: Spatial Segregation