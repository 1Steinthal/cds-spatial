---
title: "Spatial Segregation: Chicago Crime continued"
author: "Adela Sobotkova"
date: "March-2022 updated `r Sys.Date()`"
output:
  rmdformats::readthedown:
    highlight: kate
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      warnings=FALSE, 
                      message=FALSE)
```


```{r guideNOwosad, eval = FALSE, echo= FALSE}
# Spatial segregation on raster data (each race on separate raster)
# https://www.r-bloggers.com/2020/08/how-to-measure-spatial-diversity-and-segregation/
# Spatial segregation measures illustrated
# https://sejdemyr.github.io/r-tutorials/statistics/measuring-segregation.html
```

# Task 1: Prepare data for segregation
We can get a more principled measure of the violent crime ratio using a spatial segregation model. The `seg` package implements the theory of spatial segregation (Reardon and O'Sullivan 2004).

`spseg()`is a wrapper function, which calls `spatseg` to compute the set of spatial segregation measures after constructing a population density surface and its local environment parameters with user-specified options. Currently the population density surface is constructed by assuming that the population density is uniform in each census tract.
The returned value from `spseg()` in this case is a list, with `h` and `cv` elements giving the values of the statistic over the input `h` values. The `spatialkernel` package supplies a `plotcv` function to show how the test value varies. The `hcv` element has the value of the best bandwidth. For more information, see [link](https://rdrr.io/cran/seg/man/spseg.html).

Before we segregate, though, let's reduce the dataset to a smaller section.

## Instructions I

* Install `seg` package from CRAN, load `spatstat` and `sf` library. 
* Ensure that `city` boundary and the `crime_violent` simple feature object is read in (check last tutorial). 
* Create a circle around the list of supplied coordinates, and make it a simple feature object.
  - You have several options here. Perhaps elaborate on a whiteboard first?
* Use the circle to crop `crime_violent` simple feature object


```{r data-exercise, eval = FALSE}
# Libraries
library(spatstat)

# Data
chicago_crime <- ________("data/crimeCH-spatstat.rds")
Hilton <- __________

# Create a circle with 5000m radius around Hilton
c <- ____________________

# Plot the result to check it fits within Chicago
______
```

### Solution - Make a circle 

```{r data-sol, echo = FALSE}
# Libraries
library(spatstat)
library(sf)

# Data
chicago_crime <- readRDS("../data/crimeCH.rds")
crime_violent <- readRDS("../data/crime_violent.rds")
Hilton <-readRDS("../data/Hilton.rds")
city <- st_read("../data/ChicagoCity/geo_export_73f106c8-fca3-4f99-8176-1e712ec4e8f4.shp")
city <- city %>% st_transform(crs =26916)


# Create a circle with 5000m radius around Hilton
c <- st_buffer(st_as_sf(as.data.frame(Hilton), coords=c("V1", "V2"), crs = 26916), 5000)
d <- disc(centre=Hilton, radius = 5000)

# Plot the result to check it fits within Chicago

plot(city$geometry, col='light blue'); 
plot(d, col = "red", lwd = 2, add = T)
plot(c, border = "yellow", lwd = 4, add = T)

```

```{r bandwidth-prep, echo=FALSE,eval = FALSE}
# Library
library(spatstat)

# Data
#chicago_crime <- readRDS("../data/crimeCH-spatstat.rds")
# crime_violent <- readRDS("../data/crime_violent.rds")

# Create a round window around Hilton Hotel (or roughly downtown)

# Find mean center (or choose a location)
xy <- st_coordinates(crimeCH)
mc <- apply(xy, 2, mean)
mc <- cbind(mc[1]+ 5000,mc[2]-10000)
saveRDS(mc, "../data/Hilton.rds")
# standard distance
sd <- sqrt(sum((xy[,1] - mc[1])^2 + (xy[,2] - mc[2])^2) / nrow(xy))

# Plot the available data
plot(city$geometry, col='light blue')
#points(st_geometry(crimeCH), cex=.5)
points(cbind(mc[1], mc[2]), pch='*', col='red', cex=5)

# Make a circle the hard way
bearing <- 1:360 * pi/180
cx <- mc[1] + sd * cos(bearing)
cy <- mc[2] + sd * sin(bearing)
circle <- cbind(cx, cy)
plot(city$geometry, col='light blue')
points(cbind(mc[1], mc[2]), pch='*', col='red', cex=5)
lines(circle, col='red', lwd=2) # great, how do you convert it to sf?

# Make a circle simpler way
d <- disc(radius = 5000, centre = mc) # great, how do you convert it to sf?
d <- st_cast(d, "POLYGON")  # sf is not hpappy

# Make a circle the simplest way.
c <- st_buffer(st_as_sf(as.data.frame(mc), coords=c("V1", "V2"), crs = 26916), 5000)

plot(city$geometry, col='light blue'); 
plot(d, col = "red", lwd = 2, add = T)
plot(c, border = "yellow", lwd = 4, add = T)

```

## Instructions II - Crop the crime points by new circle

* bring in the old sf object `chicago_crime`
* crop it to the extent of the 5km buffer using teh circle you created above
* convert the cropped result to ppp object 
  -   consider using the disc() function to create a window, or convert circle c to an owin object
  -   use crimetype column as a basis for marks, after converting it to factor
* plot the split ppp object

```{r crop-ppp, eval=FALSE}

# Use the circle to clip crimes
crime_centre <- chicago_crime %>% 
  _____________(c) 


# Convert the cropped crimes to ppp object, consider how you can create a window

crime_violent <- ______(st_coordinates(crime_centre), W = ____)
marks(crime_violent) = as.factor(crime_centre$crimetype)
plot(split(crime_violent))
```

### Solution
```{r crop-ppp-sol, echo=FALSE}

# Use the circle to clip crimes
crime_centre <- chicago_crime %>% 
  st_intersection(c, function = withing) 


# Convert the cropped crimes to ppp object

crime_violent <- as.ppp(st_coordinates(crime_centre), W = d)
marks(crime_violent) = as.factor(crime_centre$crimetype)
plot(split(crime_violent))
```


# Task 2:  Segregation probabilities
Compute the probabilities for violent and non-violent crimes as a smooth surface, as well as the p-values for a point-wise test of segregation. This is done by calling `spseg()` with `smoothing = kernel` .

The `spseg()` function takes data and marks as two separate arguments, and you need to process the marks into a numeric matrix of at least two columns. We shall use `case_when()` again to mutate/create the violent and non-violent columns out of the `crimetype`

## Instructions

* Ensure the `chicago_centre` points data is loaded. 
* Create a column `violent` by assigning crimetype values of violent the number 1 and non-violent the number 0. Since we need two columns, create a nonviolent column doing the reverse
  - select the two new columns, drop the geometry and assign the result to `cc` object 
* Run `spseg()` function by
 - assigning the coordinates of `crime_centre` to x,
 - assigning `cc` numeric matrix to data argument and selecting `kernel` as a smoothing argument
* Use `spplot()` to plot the map for the violent/non-violent crime probability in your conference area. 

```{r seg-package-example, eval=FALSE}
#install.packages("seg")
library(seg)

# data needs to be in a numeric matrix
cc <- crime_centre %>% 
  mutate(violent = case_when(
    _________________,
   _________________
    ),nonviolent = case_when(
    _________________,
    _________________
  )) %>% 
  select(violent, nonviolent) %>% st_drop_geometry()

# run the spseg() function
pp <- spseg(x = ______(crime_centre), data=______,
            smoothing = ______, maxdist = 3000)

# Explore result
print(pp, digits = 3)
spplot(pp, main = "Kernel")

# Detach library if you wish to try others
detach("package:seg")
```


## Solution
```{r seg-package-sol, echo=FALSE}
#install.packages("seg")
library(seg)

# data needs to be in a numeric matrix
cc <- crime_centre %>% 
  mutate(violent = case_when(
    crime_centre$crimetype == "VIOLENT" ~ 1,
    crime_centre$crimetype == "NON-VIOLENT" ~ 0
    ),
    nonviolent = case_when(
    crime_centre$crimetype == "VIOLENT" ~ 0,
    crime_centre$crimetype == "NON-VIOLENT" ~ 1
  )) %>% 
  select(violent, nonviolent) %>% st_drop_geometry()

# run the spseg() function
pp <- spseg(x = st_coordinates(crime_centre), data=cc, smoothing = "kernel", maxdist = 3000)

# Look at the results
print(pp, digits = 3)
spplot(pp, main = "Kernel")

detach("package:seg")
```

Good work! The simulation shows that non-violent crime dominates around my conference location.

