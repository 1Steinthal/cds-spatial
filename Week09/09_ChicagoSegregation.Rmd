---
title: "Spatial Segregation: Chicago Crime continued"
author: "Adela Sobotkova"
date: "24 March 2022 updated `r format(Sys.time(), '%B %d, %Y')`"
output: 
  html_document:
    toc: true
    toc_float: true
    highlight: tango
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r guideNOwosad}
# Spatial segregation on raster data (each race on separate raster)
# https://www.r-bloggers.com/2020/08/how-to-measure-spatial-diversity-and-segregation/
# Spatial segregation measures illustrated
# https://sejdemyr.github.io/r-tutorials/statistics/measuring-segregation.html
```

# Task 1: Prepare data for segregation
We can get a more principled measure of the violent crime ratio using a spatial segregation model. The `seg` package implements the theory of spatial segregation (Reardon and O'Sullivan 2004).

`spseg()`is a wrapper function, which calls `spatseg` to compute the set of spatial segregation measures after constructing a population density surface and its local environment parameters with user-specified options. Currently the population density surface is constructed by assuming that the population density is uniform in each census tract.
The returned value from `spseg()` in this case is a list, with `h` and `cv` elements giving the values of the statistic over the input `h` values. The `spatialkernel` package supplies a `plotcv` function to show how the test value varies. The `hcv` element has the value of the best bandwidth. For more information, see [link](https://rdrr.io/cran/seg/man/spseg.html).

Before we segregate, though, let's reduce the dataset to a smaller section.

## Instructions I

* Install `seg` package from CRAN, load `spatstat` library. 
* Ensure that `spatstat` is loaded and the `crime_violent` simple feature object is read in (check last tutorial). 
* Create a circle around the list of supplied coordinates, and make it a simple feature object.
  - You have several options here. Perhaps elaborate on a whiteboard first?
* Use the circle to crop `crime_violent` simple feature object


```{r data-exercise, eval = FALSE}
# Libraries
library(spatstat)

# Data
chicago_crime <- ________("data/crimeCH-spatstat.rds")
Hilton <- __________

# Create a circle with 5000m radius around Hilton
c <- ____________________

# Plot the result to check it fits within Chicago
______
```

### Solution - Make a circle 

```{r data-sol, echo = FALSE}
# Libraries
library(spatstat)

# Data
chicago_crime <- readRDS("../data/crimeCH-spatstat.rds")
crime_violent <- readRDS("../data/crime_violent.rds")
Hilton <-readRDS("../data/Hilton.rds")


# Create a circle with 5000m radius around Hilton
c <- st_buffer(st_as_sf(as.data.frame(mc), coords=c("V1", "V2"), crs = 26916), 5000)


# Plot the result to check it fits within Chicago

plot(city$geometry, col='light blue'); 
plot(d, col = "red", lwd = 2, add = T)
plot(c, border = "yellow", lwd = 4, add = T)

```

```{r bandwidth-prep, echo=FALSE,eval = FALSE}
# Library
library(spatstat)

# Data
#chicago_crime <- readRDS("../data/crimeCH-spatstat.rds")
# crime_violent <- readRDS("../data/crime_violent.rds")

# Create a round window around Hilton Hotel (or roughly downtown)

# Find mean center (or choose a location)
xy <- st_coordinates(crimeCH)
mc <- apply(xy, 2, mean)
mc <- cbind(mc[1]+ 5000,mc[2]-10000)
saveRDS(mc, "../data/Hilton.rds")
# standard distance
sd <- sqrt(sum((xy[,1] - mc[1])^2 + (xy[,2] - mc[2])^2) / nrow(xy))

# Plot the available data
plot(city$geometry, col='light blue')
#points(st_geometry(crimeCH), cex=.5)
points(cbind(mc[1], mc[2]), pch='*', col='red', cex=5)

# Make a circle the hard way
bearing <- 1:360 * pi/180
cx <- mc[1] + sd * cos(bearing)
cy <- mc[2] + sd * sin(bearing)
circle <- cbind(cx, cy)
plot(city$geometry, col='light blue')
points(cbind(mc[1], mc[2]), pch='*', col='red', cex=5)
lines(circle, col='red', lwd=2) # great, how do you convert it to sf?

# Make a circle simpler way
d <- disc(radius =5000, centre = mc ) # great, how do you convert it to sf?
d <- st_cast(d, "POLYGON")  # sf is not hpappy

# Make a circle the simplest way.
c <- st_buffer(st_as_sf(as.data.frame(mc), coords=c("V1", "V2"), crs = 26916), 5000)

plot(city$geometry, col='light blue'); 
plot(d, col = "red", lwd = 2, add = T)
plot(c, border = "yellow", lwd = 4, add = T)

```

## Instructions II - Crop the crime points by new circle

* bring in the old sf object crime_v
* crop it to the extent of the 5km buffer using teh circle you created above
* convert the cropped result to ppp object 
  -   consider using the disc() function to create a window, or convert circle c to an owin object
  -   use crimetype column as a basis for marks, after converting it to factor
* plot the split ppp object

```{r crop-ppp}

# Use the circle to clip crimes
crime_centre <- crime_v %>% 
  _____________(c) 


# Convert the cropped crimes to ppp object, consider how you can create a window

crime_violent <- ______(st_coordinates(crime_centre), W = ____)
marks(crime_violent) = as.factor(crime_centre$crimetype)
plot(split(crime_violent))
```

```{r crop-ppp-sol}

# Use the circle to clip crimes
crime_centre <- crime_v %>% 
  st_intersection(c) 


# Convert the cropped crimes to ppp object

crime_violent <- as.ppp(st_coordinates(crime_centre), W = d)
marks(crime_violent) = as.factor(crime_centre$crimetype)
plot(split(crime_violent))
```


# Task 2:  Segregation probabilities
The second step is to compute the probabilities for violent and non-violent crimes as a smooth surface, as well as the p-values for a point-wise test of segregation. This is done by calling `spseg()` with `opt = 3` and a fixed bandwidth parameter `h`.

Normally you would run this process for at least 100 simulations, but that will take too long to run here. Instead, run for only 10 simulations. Then you can use a saved object `seg` which is the output from a 1000 simulation run that took about 20 minutes to complete.

## Instructions

* Ensure the `chicago_crime` points data is loaded. 
* You can also get the optimum bandwidth from the `hcv` element of `bw_choice`.
 - Set the bandwidth parameter h.
 - Run the function for 10 simulations only via the `ntest` parameter.
 - The output consists of probability maps for each class in the marks of the data. Plot the map for the violent crimes. Add "Violent crime" as the title to your plots. 


```{r seg-package-example}
#install.packages("seg")
library(seg)

# data needs to be in a numeric matrix
cc <- crime_centre %>% 
  mutate(violent = case_when(
    crime_centre$crimetype == "VIOLENT" ~ 1,
    crime_centre$crimetype == "NON-VIOLENT" ~ 0
    ),nonviolent = case_when(
    crime_centre$crimetype == "VIOLENT" ~ 0,
    crime_centre$crimetype == "NON-VIOLENT" ~ 1
  )) %>% 
  select(violent, nonviolent) %>% st_drop_geometry()

# run the spseg() function
pp <- spseg(x = st_coordinates(crime_centre), data=cc, smoothing = "kernel", maxdist = 3000, sigma = 3000)
print(pp, digits = 3)
spplot(pp, main = "Kernel")

detach("package:seg")
```

Good work! The simulation shows that non-violent crime dominates around my conference location.

