---
title: "Dis Manibus Segregation in RE"
author: "Adela Sobotkova"
date: "29/03/2022"
output:
  rmdformats::readthedown:
  highlight: kate
---

```{r setup, include=FALSE}
library(knitr)
library(rmdformats)

## Global options
options(max.print="75")
opts_chunk$set(echo=TRUE,
               cache=TRUE,
               prompt=FALSE,
               tidy=TRUE,
               comment=NA,
               message=FALSE,
               warning=FALSE)
opts_knit$set(width=75)
```

In this exercise you will map the ancient equivalent of Twitter data: the ancient inscriptions. Ancient people of class, education, and means liked to advertise their achievements and life milestones as well as their sorrows via the means of texts inscribed in stone. These epigraphic monuments were often placed near inhabited areas, roads, and gathering places where they were likely to attract the largest audience. The location of these self-expressions in space and time is a reasonable indicator of changing economic prosperity of the commissioning communities. In this exercise, you will explore how these ancient inscriptions spatially correspond to the distribution of ancient cities and settlements.  

```{r libraries, include=FALSE}
library(sf)
library(raster)
library(tidyverse)
library(leaflet)
```


# Task 1: Get spatial data for Roman Provinces


```{r load-province-data}
provinces <- st_read("https://raw.githubusercontent.com/pelagios/magis-pleiades-regions/main/pleiades-regions-magis-pelagios.geojson")
plot(provinces$geometry)
unique(provinces$name) %>% sort()
Spain <- provinces %>% filter(name %in% c("Lusitania", "Baetica", "Hispaniae")) %>% st_transform(3035)
plot(Spain$geometry)

RE <- st_union(provinces) %>% st_transform(3035)
plot(RE)
```

# Task 2: Load DM inscriptions

## Load DM inscriptions from the entire Empire
We could load the formulas for the entire Empire, but they are a bit unwieldy for the purpose of segregation, so let us instead start with the inscriptions in Spain.
```{r DM-Roman Empire, echo=FALSE}
# Load DM data for Spain
library(jsonlite)

# small 40kb new dataset from March 2022
list_json <- jsonlite::fromJSON("C:/Users/au616760/Documents/RStudio/SDAM/EDH_exploration/data/EDH_DM.json")

inscriptions = as_tibble(list_json)

# Check the first couple lines and column names
head(inscriptions)

# Wrangle the coordinates into a 2-column format - practice on a small dataset
# i_sm <- inscriptions %>% 
#   slice(1:100) %>% 
#   separate(col = coordinates, into = c("longitude","latitude"), sep = ",") %>%
#   mutate(latitude = as.numeric(gsub("_________","",latitude)),
#          longitude = as.numeric(gsub("_________","",longitude))) 

# Make a simple feature
library(sf)
inscriptions <- inscriptions %>% 
  filter(!is.na(longitude)) %>% 
  st_as_sf(coords = c("longitude", "latitude"), crs = 4326) %>% 
  st_transform(3035)

plot(inscriptions$geometry); plot(RE, add =T)
```

## Get Spain for test
```{r Spain}
# Get just Spain
library(tidyverse)

# On Home Dell
# inscriptions <- read_csv("C:/Users/Adela/Documents/RStudio/sdam/EDH_exploration/data/EDH_DM_Spain.csv")
# on Office Dell
inscription_spain <- read_csv("C:/Users/au616760/Documents/RStudio/SDAM/EDH_exploration/data/EDH_DM_Spain.csv")
head(inscription_spain)
names(inscription_spain)

# Make a simple feature
library(sf)
inscription_spain <- inscription_spain %>% 
  filter(!is.na(longitude)) %>% 
  st_as_sf(coords = c("longitude", "latitude"), crs = 4326) %>% 
  st_transform(3035)

ch <- st_buffer(st_convex_hull(st_union(inscription_spain)),100)
b <- st_make_grid(inscription_spain, n=1)
plot(inscription_spain$geometry); plot(b, add=T); plot(ch, border = "green", add=T)
```

# Start Spatial Segregation
Before attempting any spatial analysis, we need to convert data for Spain into a ppp object
```{r create-Spain-ppp}
# Libraries
library(spatstat)
library(spatialkernel)

# Data
pts <- as.matrix(st_coordinates(inscription_spain))
marks <- inscription_spain[["form_dis_manibus"]]

# Window
REbuff <- st_buffer(RE, 500)
plot(REbuff); plot(ch, col = "red", add =T)
# w <- as.owin(as_Spatial(st_sf(ch))) # does not work on school Dell, try the line below
w <- as.owin(st_sf(ch)) # does work

# density
library(maptools)
i_ppp <- as.ppp(pts, W = w)
marks(i_ppp) <- as.factor(marks)
plot(i_ppp)
plot(density(i_ppp))

```
## Basic density of Spanish formulae split by type
Here we create an `spp`, a split marked spatial pattern. The spatstat library will now read the type of formula column as a factor and group by it for the purpose of all visualisations and computations. 
```{r split-Spain-ppp}
i_spp <- split(i_ppp)
plot(density(i_spp))
```


## Look for optimal bandwidth for a kernel
```{r Spain-bandwidth}
# Scan from 1000m to 10000m in steps of 1000m
?spseg()

bw_choice <- spatialkernel::spseg(pts, marks, 
    h = seq(1000, 100000, by = 1000),
    opt = 1)

# Plot the results and highlight the best bandwidth
#plotcv(bw_choice); abline(v = bw_choice$hcv, lty = 2, col = "red") # it does not want to plot

# Print the best bandwidth
print(bw_choice$hcv)  # 6000m
```
While the `plotcv()` will not plot the range of bandwiths and their impact on the segregation, the best choice `hcv` is 6000m in the case of Spanish inscriptions with formulae.

# Task 3: DM formula proportion estimation in a given environment

```{r simulate-DM-neighborhood, echo=FALSE, }

# Set the correct bandwidth and run for 10 simulations only
seg10 <- spatialkernel::spseg(
    pts = pts,
    marks = marks,
    h = 6000,
    opt = 3,
    ntest = 10,
    proc = FALSE,
    poly = as.matrix(st_coordinates(ch)[,1:2]))

# If you are rerunning, you can reload the saved object
#seg10 <- readRDS("../data/DMseg10.rds")

# Plot the segregation map for different DIS MANIBUS formulae
unique(marks)
plotmc(seg10, "dis manibus")
plotmc(seg10, "dis manibus sacrum")
plotmc(seg10, "d m s")
plotmc(seg10, "d m")


# save the seg10 object
# saveRDS(seg10, "../data/DMseg10.rds")
```

Good work! The simulation shows that long version of dis manibus sacrus is relatively more frequent in the south of Spain, while dis manibus has a higher proportion in the north.


# Task 4: DM Segregation- Mapping segregation

With a base map and some image and contour functions we can display both the probabilities and the significance tests over the area with more control than the `plotmc()` function.

The `seg` object is a list with several components. The X and Y coordinates of the grid are stored in the `$gridx` and `$gridy` elements. The probabilities of each class of data (violent or non-violent crime) are in a matrix element `$p` with a column for each class. The p-value of the significance test is in a similar matrix element called `$stpvalue`. Rearranging columns of these matrices into a grid of values can be done with R's matrix() function. From there you can construct list objects with a vector `$x` of X-coordinates, `$y` of Y-coordinates, and `$z` as the matrix. You can then feed this to `image()` or `contour()` for visualization.

This process may seem complex, but remember that with R you can always write functions to perform complex tasks and those you may repeat often. For example, to help with the mapping in this exercise you will create a function that builds a map from four different items.

## Instructions

* Inspect the segregation object. 
  - Use `str()` to see the structure of `seg`. 
  - Set `ncol` as the length of one of the elements of `seg`.
* Create prob_violent as a list with 
  - x as the gridx element of `seg`. 
  - y as the gridy element. 
  - z as a matrix with the "dis manibus" column of the p element.
* Create `p_value` as in the previous step, except that the `z` element is logical, and `TRUE` when the `stpvalue` element of seg is less than 0.05.
* Call the `segmap()` function shown in the script to find areas where the probability of a crime being violent is above 0.15. Use 0.05 as the lower probability.

```{r segmap-dismanibus, echo=FALSE}
# Inspect the structure of the spatial segregation object
str(seg10)

# Get the number of columns in the data so we can rearrange to a grid
ncol <- length(seg10$gridy)

# Rearrange the probability column into a grid
prob_dismanibus <- list(x = seg10$gridx,
                     y = seg10$gridy,
                     z = matrix(seg10$p[, "dis manibus"],
                                ncol = ncol))
# You have basically georeferenced the image within data's coordinates
image(prob_dismanibus)

# Rearrange the p-values, but choose a p-value threshold
p_value <- list(x = seg10$gridx,
                y = seg10$gridy,
                z = matrix(seg10$stpvalue[, "dis manibus"]<= 0.1,
                                ncol = ncol))
contour(p_value)


# Create a mapping function
segmap <- function(prob_list, pv_list, low, high){

  # background map
  #library(raster)
  #plot(st_union(Spain$geometry))
  plot(REbuff)
  # p-value areas
  image(pv_list, 
        col = c("#00000000", "#FF808080"), add = TRUE) 

  # probability contours
  contour(prob_list,
          levels = c(low, high),
          col = c("#206020", "red"),
          labels = c("Low", "High"),
          add = TRUE)

  # boundary window
  plot(c, add = TRUE)
}

# Map the probability and p-value
segmap(prob_dismanibus, p_value, 0.11, 0.15)
```
```{r segmap-dismanibussacr, echo=FALSE}
# Inspect the structure of the spatial segregation object
str(seg10)

# Get the number of columns in the data so we can rearrange to a grid
ncol <- length(seg10$gridy)

# Rearrange the probability column into a grid
prob_dismanibuss <- list(x = seg10$gridx,
                     y = seg10$gridy,
                     z = matrix(seg10$p[, "dis manibus sacrum"],
                                ncol = ncol))
# You have basically georeferenced the image within data's coordinates
image(prob_dismanibuss)

# Rearrange the p-values, but choose a p-value threshold
p_value <- list(x = seg10$gridx,
                y = seg10$gridy,
                z = matrix(seg10$stpvalue[, "dis manibus sacrum"]< 0.11,
                                ncol = ncol))
contour(p_value)


# Map the probability and p-value
segmap(prob_dismanibuss, p_value, 0.11, 0.15)
```


# Task 5: Dissimilarity index
This exercise is taking the inscriptions from the entire Roman Empire, which you can reload by running the Step 2: Loading RM inscriptions, and exploring the similarity of the different 'communities' of formulae detected via a kernel of 
```{r seg-package-sol, echo=FALSE}
#install.packages("seg")
library(seg)

# data needs to be in a numeric matrix
library(tidyverse)
library(sf)
unique(inscriptions$form_dis_manibus_cons)
unique(inscriptions$form_dis_manibus)

unique(inscriptions$form_dis_manibus_ins)

i_data <- inscriptions %>% 
  dplyr::mutate(dismanibus = case_when(
    form_dis_manibus == "di manes" ~ 0,
     form_dis_manibus == "dii manes" ~ 0,
     form_dis_manibus == "dis manibus" ~ 1,
    form_dis_manibus == "diis manibus" ~ 1,
    form_dis_manibus == "dis manibus sacrum" ~ 0,
    form_dis_manibus == "diis manibus sacrum" ~ 0
    ),
    dismanibussacrum = case_when(
    form_dis_manibus == "di manes" ~ 0,
     form_dis_manibus == "dii manes" ~ 0,
     form_dis_manibus == "dis manibus" ~ 0,
    form_dis_manibus == "diis manibus" ~ 0,
    form_dis_manibus == "dis manibus sacrum" ~ 1,
    form_dis_manibus == "diis manibus sacrum" ~ 1 ),
    dimanes = case_when(
    form_dis_manibus == "di manes" ~ 1,
     form_dis_manibus == "dii manes" ~ 1,
     form_dis_manibus == "dis manibus" ~ 0,
    form_dis_manibus == "diis manibus" ~ 0,
    form_dis_manibus == "dis manibus sacrum" ~ 0,
    form_dis_manibus == "diis manibus sacrum" ~ 0)) %>% 
  dplyr::select(dismanibus, dismanibussacrum, dimanes) %>% st_drop_geometry()

# run the spseg() function
pp <- seg::spseg(x = st_coordinates(inscriptions), data=i_data, smoothing = "kernel", maxdist = 6000)

# Look at the results
print(pp, digits = 3)
spplot(pp, main = "Kernel")
help(spseg)
# To interpret the numbers check out Reardon and O'Sullivan's article
# https://onlinelibrary.wiley.com/doi/epdf/10.1111/j.0081-1750.2004.00150.x


detach("package:seg")

```
D is a measure of how different the composition of individual's local environments are , on  average, from the composition of the population as a whole. 
R is a measure of how much less diverse individuals' local environments are, on average, than is the total population of region R. It is based on spatially-weighted interaction index of population diversity (near locations contribute more than distant locations - distance-decay approach).
H is an aspatial measure of how much less diverse individuals' local environments are, on average, than is the total population of region R (entropy of local and overall environment). 1 indicates maximum segregation, - when each indviduals' local environment is monoracial, for example. 0 indicates complete integration, when each individual's local environment has the same racial composition as the total population.

P spatial exposure of one group to another in local environment. Spatial isolation is the spatial exposure of group to itself

# Task 6: Spatial clustering

```{r K-cross}
kc <- Kcross(i_ppp, i = "dis manibus", j = "dis manibus sacrum")
plot(kc)
plot(kc, . - pi * r ^ 2 ~ r)

```

This chart shows that the dis manibus and dis manibus sacrum formulae are clustered at short distances up to 50km and then dispersed, unless we consider border effects (green dotted line)

```{r K-cross-env}
#ekc <- envelope(i_ppp, Kcross, nsim = 50, i = "dis manibus", j = "dis manibus sacrum")
ekc <- readRDS("../data/DMekc.rds")
plot(ekc)
plot(ekc, . - pi * r ^ 2 ~ r)

saveRDS(ekc, "../data/DMekc.rds")

```
If we calculate an envelope of confidence, all the DM and DMS formulae are mutually clustered compared to the random distribution that one would anticipate. However at the scale of 200-600km this is not super-helpful. We need smaller more regional datasets. 

# Task 7: Start working with time
Let's break up the RE inscriptions by century

```{r load-centuries}
# Download json for 1st c CE

library(jsonlite)
# First century
download.file("https://sciencedata.dk/public/b6b6afdb969d378b70929e86e58ad975/formulae/EDH_DM_1CAD.json", "../data/EDH_DM1.json")
list_json <- jsonlite::fromJSON("../data/EDH_DM1.json")
CenturyOne <-  as_tibble(list_json)

# Second century
download.file("https://sciencedata.dk/public/b6b6afdb969d378b70929e86e58ad975/formulae/EDH_DM_2CAD.json", "../data/EDH_DM2.json")
list_json <- jsonlite::fromJSON("../data/EDH_DM2.json")
CenturyTwo <-  as_tibble(list_json)

# Third century
download.file("https://sciencedata.dk/public/b6b6afdb969d378b70929e86e58ad975/formulae/EDH_DM_3CAD.json", "../data/EDH_DM3.json")
list_json <- jsonlite::fromJSON("../data/EDH_DM3.json")
CenturyThree <-  as_tibble(list_json)


# Inspect
names(CenturyOne)
#CenturyOne$random_dates
CenturyOne$date_var_1  # first list of random generated dates from use span interval

# Spatialize
i1 <- inscriptions %>% 
  filter(id%in%CenturyOne$id) # 7 fewer than in CenturyOne

i2 <- inscriptions %>% 
  filter(id%in%CenturyTwo$id) # over 200 ids fewer
length(which(duplicated(CenturyTwo$id)))

i3 <- inscriptions %>% 
  filter(id%in%CenturyThree$id) # 2000 missing


# Alternative spatialisation
i1 <- CenturyOne %>% filter(!is.na(latitude)) %>%  
  st_as_sf(coords = c("longitude", "latitude"), crs = 4326) %>% 
  st_transform(3035)

i2 <- CenturyTwo %>% filter(!is.na(latitude)) %>%  
  st_as_sf(coords = c("longitude", "latitude"), crs = 4326) %>% 
  st_transform(3035)

i3 <- CenturyThree %>% filter(!is.na(latitude)) %>%  
  st_as_sf(coords = c("longitude", "latitude"), crs = 4326) %>% 
  st_transform(3035)

plot(i1$geometry, col = "red")
plot(i2$geometry, col = "green", add =T)
plot(i3$geometry, col = "yellow", add =T) 
plot(RE, add= T)
```

# Task 8: DM segregation results in century-slices
My expectation is for higher values of segregation-isolation as aggregation will increase diversity.

## First century
```{r seg-1AD}
i1_data <- i1 %>% 
  dplyr::mutate(dismanibus = case_when(
    form_dis_manibus == "di manes" ~ 0,
     form_dis_manibus == "dii manes" ~ 0,
     form_dis_manibus == "dis manibus" ~ 1,
    form_dis_manibus == "diis manibus" ~ 1,
    form_dis_manibus == "dis manibus sacrum" ~ 0,
    form_dis_manibus == "diis manibus sacrum" ~ 0
    ),
    dismanibussacrum = case_when(
    form_dis_manibus == "di manes" ~ 0,
     form_dis_manibus == "dii manes" ~ 0,
     form_dis_manibus == "dis manibus" ~ 0,
    form_dis_manibus == "diis manibus" ~ 0,
    form_dis_manibus == "dis manibus sacrum" ~ 1,
    form_dis_manibus == "diis manibus sacrum" ~ 1 ),
    dimanes = case_when(
    form_dis_manibus == "di manes" ~ 1,
     form_dis_manibus == "dii manes" ~ 1,
     form_dis_manibus == "dis manibus" ~ 0,
    form_dis_manibus == "diis manibus" ~ 0,
    form_dis_manibus == "dis manibus sacrum" ~ 0,
    form_dis_manibus == "diis manibus sacrum" ~ 0)) %>% 
  dplyr::select(dismanibus, dismanibussacrum, dimanes) %>% st_drop_geometry()

# run the spseg() function
pp1 <- seg::spseg(x = st_coordinates(i1), data=i1_data, smoothing = "kernel", maxdist = 6000)

# Look at the results
print(pp1, digits = 3)
spplot(pp1, main = "Kernel")
help(spseg)
```
## Second century
```{r seg-2AD}
i2_data <- i2 %>% 
  dplyr::mutate(dismanibus = case_when(
    form_dis_manibus == "di manes" ~ 0,
     form_dis_manibus == "dii manes" ~ 0,
     form_dis_manibus == "dis manibus" ~ 1,
    form_dis_manibus == "diis manibus" ~ 1,
    form_dis_manibus == "dis manibus sacrum" ~ 0,
    form_dis_manibus == "diis manibus sacrum" ~ 0
    ),
    dismanibussacrum = case_when(
    form_dis_manibus == "di manes" ~ 0,
     form_dis_manibus == "dii manes" ~ 0,
     form_dis_manibus == "dis manibus" ~ 0,
    form_dis_manibus == "diis manibus" ~ 0,
    form_dis_manibus == "dis manibus sacrum" ~ 1,
    form_dis_manibus == "diis manibus sacrum" ~ 1 ),
    dimanes = case_when(
    form_dis_manibus == "di manes" ~ 1,
     form_dis_manibus == "dii manes" ~ 1,
     form_dis_manibus == "dis manibus" ~ 0,
    form_dis_manibus == "diis manibus" ~ 0,
    form_dis_manibus == "dis manibus sacrum" ~ 0,
    form_dis_manibus == "diis manibus sacrum" ~ 0)) %>% 
  dplyr::select(dismanibus, dismanibussacrum, dimanes) %>% st_drop_geometry()

# run the spseg() function
pp2 <- seg::spseg(x = st_coordinates(i2), data=i2_data, smoothing = "kernel", maxdist = 6000)

# Look at the results
print(pp2, digits = 3)
spplot(pp2, main = "Kernel")
help(spseg)
```

## Third century

```{r seg-3AD}
i3_data <- i3 %>% 
  dplyr::mutate(dismanibus = case_when(
    form_dis_manibus == "di manes" ~ 0,
     form_dis_manibus == "dii manes" ~ 0,
     form_dis_manibus == "dis manibus" ~ 1,
    form_dis_manibus == "diis manibus" ~ 1,
    form_dis_manibus == "dis manibus sacrum" ~ 0,
    form_dis_manibus == "diis manibus sacrum" ~ 0
    ),
    dismanibussacrum = case_when(
    form_dis_manibus == "di manes" ~ 0,
     form_dis_manibus == "dii manes" ~ 0,
     form_dis_manibus == "dis manibus" ~ 0,
    form_dis_manibus == "diis manibus" ~ 0,
    form_dis_manibus == "dis manibus sacrum" ~ 1,
    form_dis_manibus == "diis manibus sacrum" ~ 1 ),
    dimanes = case_when(
    form_dis_manibus == "di manes" ~ 1,
     form_dis_manibus == "dii manes" ~ 1,
     form_dis_manibus == "dis manibus" ~ 0,
    form_dis_manibus == "diis manibus" ~ 0,
    form_dis_manibus == "dis manibus sacrum" ~ 0,
    form_dis_manibus == "diis manibus sacrum" ~ 0)) %>% 
  dplyr::select(dismanibus, dismanibussacrum, dimanes) %>% st_drop_geometry()

# run the spseg() function
pp3 <- seg::spseg(x = st_coordinates(i3), data=i3_data, smoothing = "kernel", maxdist = 6000)

# Look at the results
print(pp3, digits = 3)
spplot(pp3, main = "Kernel")
```