---
title: "09_DMtemporal"
author: "Adela"
date: '2022-05-25'
output: html_document
---


```{r setup, include=FALSE}
library(knitr)
library(rmdformats)

## Global options
options(max.print="75")
opts_chunk$set(echo=TRUE,
               cache=TRUE,
               prompt=FALSE,
               tidy=TRUE,
               comment=NA,
               message=FALSE,
               warning=FALSE)
opts_knit$set(width=75)
```

In this exercise you will map the ancient equivalent of Twitter data: the ancient inscriptions. Ancient people of class, education, and means liked to advertise their achievements and life milestones as well as their sorrows via the means of texts inscribed in stone. These epigraphic monuments were often placed near inhabited areas, roads, and gathering places where they were likely to attract the largest audience. The location of these self-expressions in space and time is a reasonable indicator of changing economic prosperity of the commissioning communities. In this exercise, you will explore how these ancient inscriptions spatially correspond to the distribution of ancient cities and settlements.  

```{r libraries, include=FALSE}
library(sf)
library(raster)
library(tidyverse)
library(leaflet)
```


# Task 7: Start working with time
Let's break up the RE inscriptions by century

```{r load-centuries}
# Download json for 1st c CE

library(jsonlite)
# First century
download.file("https://sciencedata.dk/public/b6b6afdb969d378b70929e86e58ad975/formulae/EDH_DM_1CAD.json", "../data/EDH_DM1.json")
list_json <- jsonlite::fromJSON("../data/EDH_DM1.json")
CenturyOne <-  as_tibble(list_json)

# Second century
download.file("https://sciencedata.dk/public/b6b6afdb969d378b70929e86e58ad975/formulae/EDH_DM_2CAD.json", "../data/EDH_DM2.json")
list_json <- jsonlite::fromJSON("../data/EDH_DM2.json")
CenturyTwo <-  as_tibble(list_json)

# Third century
download.file("https://sciencedata.dk/public/b6b6afdb969d378b70929e86e58ad975/formulae/EDH_DM_3CAD.json", "../data/EDH_DM3.json")
list_json <- jsonlite::fromJSON("../data/EDH_DM3.json")
CenturyThree <-  as_tibble(list_json)


# Inspect
names(CenturyOne)
CenturyOne$random_dates
CenturyOne$date_var_1  # first list of random generated dates from use span interval

# Spatialize
i1 <- inscriptions %>% 
  filter(id%in%CenturyOne$id) # 7 fewer than in CenturyOne

i2 <- inscriptions %>% 
  filter(id%in%CenturyTwo$id) # over 200 ids fewer
length(which(duplicated(CenturyTwo$id)))

i3 <- inscriptions %>% 
  filter(id%in%CenturyThree$id) # 2000 missing


# Alternative spatialisation
i1 <- CenturyOne %>% filter(!is.na(latitude)) %>%  
  st_as_sf(coords = c("longitude", "latitude"), crs = 4326) %>% 
  st_transform(3035)

i2 <- CenturyTwo %>% filter(!is.na(latitude)) %>%  
  st_as_sf(coords = c("longitude", "latitude"), crs = 4326) %>% 
  st_transform(3035)

i3 <- CenturyThree %>% filter(!is.na(latitude)) %>%  
  st_as_sf(coords = c("longitude", "latitude"), crs = 4326) %>% 
  st_transform(3035)

plot(i1$geometry, col = "red")
plot(i2$geometry, col = "green", add =T)
plot(i3$geometry, col = "yellow", add =T) 
plot(RE, add= T)
```

# Task 8: DM segregation results in century-slices
My expectation is for higher values of segregation-isolation as aggregation will increase diversity.

## First century
```{r seg-1AD}
i1_data <- i1 %>% 
  dplyr::mutate(dismanibus = case_when(
    form_dis_manibus == "di manes" ~ 0,
     form_dis_manibus == "dii manes" ~ 0,
     form_dis_manibus == "dis manibus" ~ 1,
    form_dis_manibus == "diis manibus" ~ 1,
    form_dis_manibus == "dis manibus sacrum" ~ 0,
    form_dis_manibus == "diis manibus sacrum" ~ 0
    ),
    dismanibussacrum = case_when(
    form_dis_manibus == "di manes" ~ 0,
     form_dis_manibus == "dii manes" ~ 0,
     form_dis_manibus == "dis manibus" ~ 0,
    form_dis_manibus == "diis manibus" ~ 0,
    form_dis_manibus == "dis manibus sacrum" ~ 1,
    form_dis_manibus == "diis manibus sacrum" ~ 1 ),
    dimanes = case_when(
    form_dis_manibus == "di manes" ~ 1,
     form_dis_manibus == "dii manes" ~ 1,
     form_dis_manibus == "dis manibus" ~ 0,
    form_dis_manibus == "diis manibus" ~ 0,
    form_dis_manibus == "dis manibus sacrum" ~ 0,
    form_dis_manibus == "diis manibus sacrum" ~ 0)) %>% 
  dplyr::select(dismanibus, dismanibussacrum, dimanes) %>% st_drop_geometry()

# run the spseg() function
pp1 <- seg::spseg(x = st_coordinates(i1), data=i1_data, smoothing = "kernel", maxdist = 6000)

# Look at the results
print(pp1, digits = 3)
spplot(pp1, main = "Kernel")
help(spseg)
```
## Second century
```{r seg-2AD}
i2_data <- i2 %>% 
  dplyr::mutate(dismanibus = case_when(
    form_dis_manibus == "di manes" ~ 0,
     form_dis_manibus == "dii manes" ~ 0,
     form_dis_manibus == "dis manibus" ~ 1,
    form_dis_manibus == "diis manibus" ~ 1,
    form_dis_manibus == "dis manibus sacrum" ~ 0,
    form_dis_manibus == "diis manibus sacrum" ~ 0
    ),
    dismanibussacrum = case_when(
    form_dis_manibus == "di manes" ~ 0,
     form_dis_manibus == "dii manes" ~ 0,
     form_dis_manibus == "dis manibus" ~ 0,
    form_dis_manibus == "diis manibus" ~ 0,
    form_dis_manibus == "dis manibus sacrum" ~ 1,
    form_dis_manibus == "diis manibus sacrum" ~ 1 ),
    dimanes = case_when(
    form_dis_manibus == "di manes" ~ 1,
     form_dis_manibus == "dii manes" ~ 1,
     form_dis_manibus == "dis manibus" ~ 0,
    form_dis_manibus == "diis manibus" ~ 0,
    form_dis_manibus == "dis manibus sacrum" ~ 0,
    form_dis_manibus == "diis manibus sacrum" ~ 0)) %>% 
  dplyr::select(dismanibus, dismanibussacrum, dimanes) %>% st_drop_geometry()

# run the spseg() function
pp2 <- seg::spseg(x = st_coordinates(i2), data=i2_data, smoothing = "kernel", maxdist = 6000)

# Look at the results
print(pp2, digits = 3)
spplot(pp2, main = "Kernel")
help(spseg)
```

## Third century

```{r seg-3AD}
i3_data <- i3 %>% 
  dplyr::mutate(dismanibus = case_when(
    form_dis_manibus == "di manes" ~ 0,
     form_dis_manibus == "dii manes" ~ 0,
     form_dis_manibus == "dis manibus" ~ 1,
    form_dis_manibus == "diis manibus" ~ 1,
    form_dis_manibus == "dis manibus sacrum" ~ 0,
    form_dis_manibus == "diis manibus sacrum" ~ 0
    ),
    dismanibussacrum = case_when(
    form_dis_manibus == "di manes" ~ 0,
     form_dis_manibus == "dii manes" ~ 0,
     form_dis_manibus == "dis manibus" ~ 0,
    form_dis_manibus == "diis manibus" ~ 0,
    form_dis_manibus == "dis manibus sacrum" ~ 1,
    form_dis_manibus == "diis manibus sacrum" ~ 1 ),
    dimanes = case_when(
    form_dis_manibus == "di manes" ~ 1,
     form_dis_manibus == "dii manes" ~ 1,
     form_dis_manibus == "dis manibus" ~ 0,
    form_dis_manibus == "diis manibus" ~ 0,
    form_dis_manibus == "dis manibus sacrum" ~ 0,
    form_dis_manibus == "diis manibus sacrum" ~ 0)) %>% 
  dplyr::select(dismanibus, dismanibussacrum, dimanes) %>% st_drop_geometry()

# run the spseg() function
pp3 <- seg::spseg(x = st_coordinates(i3), data=i3_data, smoothing = "kernel", maxdist = 6000)

# Look at the results
print(pp3, digits = 3)
spplot(pp3, main = "Kernel")
help(spseg)
```


# Task 9: Space-time modelling with splancs? (needs interpretation)
Grab a random date for each inscription `i1$date_var_1` and use it to simulate a date
Aggregate i1 - i3 and run space-time analysis on it to see if there is a temporal pattern to the emergence of the formulae.

To do a space-time clustering test with `stmctest()` from the `splancs` package, you first need to convert parts of your `ppp` object. Functions in `splancs` tend to use matrix data instead of data frames.

To run `stmctest()` you need to set up the following:

- event locations
- event times
- region polygon
- time limits
- the time and space ranges for analysis.


```{r cluster-centuries, echo=FALSE}
#Libraries
library(spatstat)
library(splancs)

# Data
i123 <- rbind(i1, i2, i3)

# Get a matrix of event coordinates
i_xy <- as.matrix(st_coordinates(i123))

# Check the matrix has two columns
dim(i_xy)

# Get a vector of event times
names(i123)
i_t <- i123$date_var_1

# Extract a two-column matrix from the ppp object
i_poly <- as.matrix(window)
dim(i_poly)

# Set the time limit to 1 day before and 1 day after the range of times
tlimits <- range(i_t) + c(-1, 1)

# Scan over 6000m intervals from 1000m to 20000km
s <- seq(1000, 20000, by = 6000)

# Scan over 14 day intervals from one week to 31 weeks
tm <- seq(1,400, by = 7)

```

Gosh, what a lot of set-up! Now for the action.
## Monte Carlo test 

Everything is now ready for you to run the space-time clustering test function. You can then plot the results and compute a `p-value` for rejecting the null hypothesis of no space-time clustering.

Any space-time clustering in a data set will be removed if you randomly rearrange the dates of the data points. The `stmctest()` function computes a clustering test statistic for your data based on the space-time K-function - how many points are within a spatial and temporal window of a point of the data. It then does a number of random rearrangements of the dates among the points and computes the clustering statistic. After doing this a large number of times, you can compare the test statistic for your data with the values from the random data. If the test statistic for your data is sufficiently large or small, you can reject the null hypothesis of no space-time clustering.

The output from `stmctest(`) is a list with a single `t0` which is the test statistic for your data, and a vector of `t` from the simulations. By converting to data frame you can feed this to `ggplot` functions.

Because the window area is a large number of square meters, and we have about 400 events, the numerical value of the intensity is a very small number. This makes values of the various K-functions very large numbers, since they are proportional to the inverse of the intensity. Don't worry if you see 10^10 or higher!

The `p-value` of a Monte-Carlo test like this is just the proportion of test statistics that are larger than the value from the data. You can compute this from the `t` and `t0` elements of the output.

## Instructions

* Ensure that all the objects from the previous exercise are loaded.
* Run `stmctest()` for 999 simulations.
* Draw a histogram of times.
* The x-aesthetic is `t`.
* Add a vertical line at the `t0` value.
* Sum up how many `t` values are larger than the `t0` value, and compute as a proportion. 

```{r MC-sol, echo=FALSE}
# Run 999 simulations 
i_mc <- stmctest(i_xy, i_t, i_poly, tlimits, s, tm, nsim = 99, quiet = TRUE)
names(i_mc)

# Histogram the simulated statistics and add a line at the data value
library(ggplot2)
ggplot(data.frame(i_mc), aes(x = t)) + 
  geom_histogram() + 
  geom_vline(aes(xintercept = t0))

# Compute the p-value as the proportion of tests greater than the data
sum(i_mc$t > i_mc$t0) / 1000
```
p = 0.099 is not great
Monte Carlo simulation!

# Task 10: Space-time over specific DM formulae -- SOMETIMES CRASHES! 
Let's use the split-up i and model different formulae in time, starting with dis manibus.

More meaning needs to be injected here.

```{r cluster-dis+manibus, echo=FALSE, eval=FALSE}
#Libraries
library(spatstat)
library(splancs)

# Data
i123 <- rbind(i1, i2, i3)
i123 <- cbind(i, century = c(rep(1,428), rep(2, 4959), rep(3,3137)))
# Get a matrix of event coordinates
idm_xy <- as.matrix(st_coordinates(i123 %>% 
                                    filter(form_dis_manibus=="dis manibus")))

# Check the matrix has two columns
dim(idm_xy)

# Get a vector of event times
names(i123)
idm_t <- i123$date_var_1

# Extract a two-column matrix from the ppp object
i_poly <- as.matrix(window)
dim(i_poly)

# Set the time limit to 1 day before and 1 day after the range of times
tlimits <- range(idm_t) + c(-1, 1)

# Scan over 6000m intervals from 1000m to 20000km
s <- seq(1000, 20000, by = 6000)

# Scan over 14 day intervals from one week to 31 weeks
tm <- seq(1,400, by = 7)

# Monte Carlo: Run 999 simulations 
idm_mc <- stmctest(i_xy, idm_t, i_poly, tlimits, s, tm, nsim = 99, quiet = TRUE)
names(idm_mc)

# Histogram the simulated statistics and add a line at the data value
library(ggplot2)
ggplot(data.frame(idm_mc), aes(x = t)) + 
  geom_histogram() + 
  geom_vline(aes(xintercept = t0))

# Compute the p-value as the proportion of tests greater than the data
sum(i_mc$t > i_mc$t0) / 1000

```

