---
title: "Ease of Travel"
author: "Adela Sobotkova"
date: "11/04/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
# Why calculating travel cost matters
Humans need protection, provision, and meaning to their lives, and most of these activities happen in proximity to their abodes but not always at home. Movement matters, and ease of movement often determines where people go. 

Many studies recognise the higher cost of tending fields and crops and the associated reduction in yields which occur with increasing distance from settlements (Lee 1969; Chisholm 1962; Vita-Finzi & Higgs 1970; Dennell & Webley 1975; Roper 1979). 

Time and friction of the surrounding environment pose obstacles to human activities and aggregation and need to be overcome as people wish to socialize and gather.

There are a number of ways to calculate the cost of movement (see 
https://www.spatialanalysisonline.com/HTML/index.html?cost_distance.htm)

Counting with time is another representation of travel. 

# Tobler's Hiker algorithm
Waldo Tobler's paper: https://escholarship.org/content/qt05r820mz/qt05r820mz.pdf

`walkrate = a*exp(-b*abs(S+c))`

* walking velocity is in km/h
* S = height difference/distance (in same units)
* c is 0.05 constant that gets us to 5 km/h on the flat terrain
* for off-path travel, multiply by 0.6, for horseback, multiply by 1.25.
* travel time is computed as distance/velocity

Calculations are best done in a geographic matrix, with elevations at equally spaced increments in two directions (or need correction).
Then one can compute, from any inital point, the minimum time path to all other places (Figure IVa).
Connecting places at equal time-distances yields isochronic lines, or "geographic circles" (Figure IVb). Putting in the gradients to this contour map then yields two sets of orthogonal lines (Figure IVc), isomorphic with Gauss’ geodesic polar coordinates for which the metric takes on a particularly simple form.

# Implemented in gdistance package
http://www2.uaem.mx/r-mirror/web/packages/gdistance/vignettes/gdistance-vignette.pdf
```{r getting-started}
# Example
library(gdistance)
library(raster)
# example equivalent to that in the documentation on r.cost in GRASS
r <- raster(nrows=6, ncols=7, 
            xmn=0, xmx=7, 
            ymn=0, ymx=6, 
            crs="+proj=utm +units=m")

r[] <- c(2, 2, 1, 1, 5, 5, 5,
         2, 2, 8, 8, 5, 2, 1,
         7, 1, 1, 8, 2, 2, 2,
         8, 7, 8, 8, 8, 8, 5,
         8, 8, 1, 1, 5, 3, 9,
         8, 1, 1, 2, 5, 3, 9)

# 1/mean: reciprocal to get permeability
tr <- transition(r, function(x) 1/mean(x), 8) 
tr <- geoCorrection(tr)

c1 <- c(5.5,1.5) 
c2 <- c(1.5,5.5)

A <- accCost(tr, c1)
plot(A)
text(A)
hist(A)
```



## Tobler's hiker formula
```{r tobler}
# Flat terrain comes to 5 km per hour
slope <- 0.0
travelcost <-6*exp(-3.5*abs(slope+0.05)) # on foot on path ~ 5km/h
travelcost_op <-6*exp(-3.5*abs(slope+0.05))*0.6 # off path ~ 3km/h

```

## Maunga Whay Volcano example (part of r base data)
http://www2.uaem.mx/r-mirror/web/packages/gdistance/vignettes/gdistance-vignette.pdf
```{r}
?volcano
r <- raster(system.file("external/maungawhau.grd", package="gdistance"))
plot(r) # plot volcano
hist(r)
```

The Hiking Function requires the slope as input.
slope = difference in height / distance travelled

```{r}
heightDiff <- function(x){x[2] - x[1]}
hd <- transition(r,heightDiff,8,symm=FALSE)
hd
slope <- geoCorrection(hd, scl=FALSE)
slope
plot(raster(slope))
hist(values(raster(slope)), xlab = "degrees")
```

Subsequently, we calculate the speed. We need to exercise special care, because the matrix value between non-adjacent cells is 0, but the slope between these cells is not 0! Therefore, we need to restrict the calculation to adjacent cells. We do this by creating an index for adjacent cells (adj) with the function `adjacent()`. Using this index, we extract and replace adjacent cells, without touching the other values

```{r adjacent-speed}
# tobler
# 6 * 1000 * exp(-3.5 * abs(0 + 0.05))
adj <- adjacent(r, cells=1:ncell(r), pairs=TRUE, directions=8)
speed <- slope
# for kms per hour, eliminate 1000 before exp. We keep meters, because CRS is meters
speed[adj] <- 6 * 1000* exp(-3.5 * abs(slope[adj] + 0.05))
plot(raster(speed), main = "Friction of surface in meters/hour") 
```

Now we have calculated the speed of movement between adjacent cells. We are close to having the final conductance values. Attainable speed is a measure of the ease of crossing from one cell to another on the grid. However, we also need to take into account the distance between cell centres. Travelling with the same speed, a diagonal connection between cells takes longer to cross than a straight connection. Therefore, we use the function `geoCorrection()` again!

```{r geocorrection}
x <- geoCorrection(speed, scl = FALSE)
plot(raster(x), main = "Conductance to travel - meters/hour")
```

This gives our final ”conductance” values.
What do these ”conductance” values mean? The function `geoCorrection` divides the values in the matrix with the distance between cell centres. So, with our last command we calculated this:

conductance = speed / distance

This looks a lot like a measure that we are more familiar with:

travel time = distance / speed

In fact, the conductance values we have calculated are the reciprocal of travel time.

1 / travel time = speed / distance = conductance

Maximizing the reciprocal of travel time is exactly equivalent to minimizing travel time.

# Distance in cost grid
Now, let's define two coordinates, A and B, and calculate least cost paths between them. We test if the quickest path from A to B is the same as the quickest part from B to A.
```{r}
A <- c(2667670,6479000)
B <- c(2667800,6479400)
AtoB <- shortestPath(x, A, B, output="SpatialLines")
BtoA <- shortestPath(x, B, A, output="SpatialLines")

plot(r)
lines(AtoB, col="red", lwd=2)
lines(BtoA, col="blue")
text(A[1]-10,A[2]-10,"A")
text(B[1]+10,B[2]+10,"B")
```
A small part of the A-B (red) and B-A (blue) lines in the figure do not
overlap. This is a consequence of the asymmetry of the Hiking Function

## What's the length and cost of these paths?
```{r length-cost}
# Length
library(sf)
st_length(st_as_sf(AtoB)) #  486m
st_length(st_as_sf(BtoA))
```
# What's the cost of the path?
```{r cost-path}
# to understand units, check out https://stackoverflow.com/questions/36523709/r-gdistance-different-results-for-acccost-and-costdistance

# Cost
plot(raster(speed))
contour(raster(speed), add = TRUE)

# Extract cost cells for the AtoB path
AtoBcost <- raster::overlay(raster(x), rasterize(AtoB, raster(x)), fun = "sum")
plot(AtoBcost) # see path colorcoded by travel difficulty

sum(na.omit(values(AtoBcost))) # what does the 17866.48 number mean, actually?

# Cost distance function
library(gdistance)
costDistance(x,fromCoords=A,toCoords=B) # 0.12h

ca <- accCost(x,fromCoords=A)
extract(ca,B)

plot(ca, main = "Cost of traversing a cell in hours")
```

# Plot the points (needs conversion)
```{r}
library(sf)
pointsdf <- data.frame(rbind(A, B))
points <- st_as_sf(pointsdf,
               coords=c("X1","X2"), 
               crs = st_crs(x))

plot(raster(speed), main = "Raw speed in m/h"); plot(points, add = TRUE)
plot(raster(x), main = "Corrected conductance grid"); plot(points, add = TRUE)
```



# Accummulated Cost Surface - isochrones
Isochrones connect cells that take the same amount of time to cross.
```{r}
plot(raster(x))

library(gdistance)
library(sp)
library(sf)
y <- accCost(x, fromCoords = as(points, "Spatial"))
plot(y, main = "cost of travel in hours"); plot(as(points, "Spatial"), add =TRUE); contour(y, add =TRUE )

# Compare with raw cost distance *nearly no difference
yraw <- accCost(speed,fromCoords = as(points, "Spatial"))

dir.create("outputs")
pdf("outputs/CostSurface.pdf")
plot(y, main = "cost of travel in hours"); plot(as(points, "Spatial"), add =TRUE); contour(y, add =TRUE )
dev.off()
```
## Least cost paths in Yambol region: multiple points

```{r}
library(tidyverse)

# load obstacle: the river
Tonzos <- read_sf("~/../Desktop/TRAP_Oxbow/TopoData/Tonzos.shp")
Tonzos <- Tonzos %>% st_transform(32635)

# Add major/random settlements within region
settle <- read_sf("~/../Desktop/TRAP_Oxbow/TopoData/Modern_settlements_Yambol_TRAP.shp")
settle <- settle %>% 
 # st_drop_geometry() %>% 
  dplyr::filter(!is.na(NAME_map)) %>% 
  dplyr::select(NAME_map | ends_with("_en")) %>% 
  st_centroid()

# Add via diagonalis
diagonalis <- read_sf("~/../Desktop/TRAP_Oxbow/TopoData/Roman_roads_BarringtonAtlas.shp")
viae <- diagonalis %>% 
  st_transform(32635) %>% 
  st_intersection(Y_region)

plot(viae)

# load entryways into the region
border <- st_make_grid(settle, n= 1)
plot(settle$geometry); plot(border, add =T)
Y_region <- read_sf("~/../Desktop/TRAP_Oxbow/TopoData/Yambol_municipalities.shp")
Y_region <- st_union(Y_region$geometry)
plot(Y_region)

# cast border into points
test <- Y_region %>% 
  st_buffer(200) %>% 
  st_simplify(dTolerance = 500) %>%  # to be simpler
  st_convex_hull() %>% 
  st_cast(to = "POINT")
plot(test[-c(7,9,13,14)])


places <- data.frame(name = c("Topolovgrad", "Krushare", "Prohod", "Valchanovo", "Zheleznik"),
                     lat = c(42.09177426394385,42.5581286490158,42.327922453869185,
                             42.26295408961938, 42.56753262714555),
                     long = c(26.34963390596414,26.389174645837592, 27.0540046157391, 27.084479032105204, 26.90031980591084))

places <- places %>% 
  st_as_sf(coords = c("long", "lat"), crs = 4326) %>% 
  st_transform(32635)

library(mapview)
mapview(test[-c(7,9,13,14)]) + mapview(places) #+ mapview(settle)
test <- test[-c(7,9,13,14)]

border <- c(places, st_sf(test))
border <- c(places$geometry, test)

mapview(st_sf(border))
# Plot everything
mapview(Tonzos) + mapview(settle)+mapview(border)

# Give border points names
border <- border %>% 
  st_as_sf() %>% 
  mutate(name = letters[1:18])
```

## Convert everything into raster or spatial format
```{r}
Y_elev <- raster("../../../YambolMoundAnalysis2023/output_data/large/YT_elev32635.tif")
Y_elev <- crop(Y_elev, st_sf(border))
Y_elev_sm <- aggregate(Y_elev, fact=5)
plot(Y_elev)
tonzos <- st_intersection(Tonzos, st_convex_hull(st_union(border)))
library(raster)
r <- raster(Y_elev_sm)
t <- rasterize(as(tonzos,"Spatial"), r)
mapview(t)
t <- reclassify(t, rcl = cbind(1,-100))

t <- reclassify(t, rcl = cbind(NA,1))
unique(values(t))
f <- function(r1,r2){
  r1 + r2
}
elev_t <-overlay(Y_elev_sm, t, fun = f) 
mapview(elev_t)
```


## Calculate a LCP network following Tobler

origin must be a spatial object with a name. plain geometry errors out.
```{r}
# uses the on-path Tobler's hiking function

library(movecost)
lcp <- movenetw(dtm = elev_t, origin = as(settle, "Spatial"), barrier = as(viae, "Spatial"), field = 10, move = 8, funct = "t", lcp.dens = TRUE, export = TRUE)
saveRDS(lcp, "../data/lcp.rds")
plot(lcp$LCPs.density.perc)
plot(lcp$LCPs.density.count)

plot(elev_t);plot(lcp$LCPs.netw.merged, add =T, col = "darkgrey");
plot(viae$geometry, col = "darkgreen", add = T);
plot(settle$geometry, add = T, col = "red");
plot(Y_region, add = T, borders = "grey")
# add most prominent mounds to the view
plot(mounds)
```



